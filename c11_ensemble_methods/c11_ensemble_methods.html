<!DOCTYPE html>
<html lang="en"><head>
<script src="../libs/clipboard/clipboard.min.js"></script>
<script src="../libs/quarto-html/tabby.min.js"></script>
<script src="../libs/quarto-html/popper.min.js"></script>
<script src="../libs/quarto-html/tippy.umd.min.js"></script>
<link href="../libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../libs/quarto-html/quarto-html.min.css" rel="stylesheet" data-mode="light">
<link href="../libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.3.433">

  <title>Ensemble Methods: Random Forest and Boosting</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      { color: #24292e;  }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #24292e; } /* Normal */
    code span.al { color: #ff5555; font-weight: bold; } /* Alert */
    code span.an { color: #6a737d; } /* Annotation */
    code span.at { color: #d73a49; } /* Attribute */
    code span.bn { color: #005cc5; } /* BaseN */
    code span.bu { color: #d73a49; } /* BuiltIn */
    code span.cf { color: #d73a49; } /* ControlFlow */
    code span.ch { color: #032f62; } /* Char */
    code span.cn { color: #005cc5; } /* Constant */
    code span.co { color: #6a737d; } /* Comment */
    code span.cv { color: #6a737d; } /* CommentVar */
    code span.do { color: #6a737d; } /* Documentation */
    code span.dt { color: #d73a49; } /* DataType */
    code span.dv { color: #005cc5; } /* DecVal */
    code span.er { color: #ff5555; text-decoration: underline; } /* Error */
    code span.ex { color: #d73a49; font-weight: bold; } /* Extension */
    code span.fl { color: #005cc5; } /* Float */
    code span.fu { color: #6f42c1; } /* Function */
    code span.im { color: #032f62; } /* Import */
    code span.in { color: #6a737d; } /* Information */
    code span.kw { color: #d73a49; } /* Keyword */
    code span.op { color: #24292e; } /* Operator */
    code span.ot { color: #6f42c1; } /* Other */
    code span.pp { color: #d73a49; } /* Preprocessor */
    code span.re { color: #6a737d; } /* RegionMarker */
    code span.sc { color: #005cc5; } /* SpecialChar */
    code span.ss { color: #032f62; } /* SpecialString */
    code span.st { color: #032f62; } /* String */
    code span.va { color: #e36209; } /* Variable */
    code span.vs { color: #032f62; } /* VerbatimString */
    code span.wa { color: #ff5555; } /* Warning */
  </style>
  <link rel="stylesheet" href="../libs/revealjs/dist/theme/quarto.css">
  <link rel="stylesheet" href="../slides_quarto.css">
  <link href="../libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-chalkboard/font-awesome/css/all.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/reveal-chalkboard/style.css" rel="stylesheet">
  <link href="../libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">

  .callout {
    margin-top: 1em;
    margin-bottom: 1em;  
    border-radius: .25rem;
  }

  .callout.callout-style-simple { 
    padding: 0em 0.5em;
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
    display: flex;
  }

  .callout.callout-style-default {
    border-left: solid #acacac .3rem;
    border-right: solid 1px silver;
    border-top: solid 1px silver;
    border-bottom: solid 1px silver;
  }

  .callout .callout-body-container {
    flex-grow: 1;
  }

  .callout.callout-style-simple .callout-body {
    font-size: 1rem;
    font-weight: 400;
  }

  .callout.callout-style-default .callout-body {
    font-size: 0.9rem;
    font-weight: 400;
  }

  .callout.callout-titled.callout-style-simple .callout-body {
    margin-top: 0.2em;
  }

  .callout:not(.callout-titled) .callout-body {
      display: flex;
  }

  .callout:not(.no-icon).callout-titled.callout-style-simple .callout-content {
    padding-left: 1.6em;
  }

  .callout.callout-titled .callout-header {
    padding-top: 0.2em;
    margin-bottom: -0.2em;
  }

  .callout.callout-titled .callout-title  p {
    margin-top: 0.5em;
    margin-bottom: 0.5em;
  }
    
  .callout.callout-titled.callout-style-simple .callout-content  p {
    margin-top: 0;
  }

  .callout.callout-titled.callout-style-default .callout-content  p {
    margin-top: 0.7em;
  }

  .callout.callout-style-simple div.callout-title {
    border-bottom: none;
    font-size: .9rem;
    font-weight: 600;
    opacity: 75%;
  }

  .callout.callout-style-default  div.callout-title {
    border-bottom: none;
    font-weight: 600;
    opacity: 85%;
    font-size: 0.9rem;
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-default div.callout-content {
    padding-left: 0.5em;
    padding-right: 0.5em;
  }

  .callout.callout-style-simple .callout-icon::before {
    height: 1rem;
    width: 1rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 1rem 1rem;
  }

  .callout.callout-style-default .callout-icon::before {
    height: 0.9rem;
    width: 0.9rem;
    display: inline-block;
    content: "";
    background-repeat: no-repeat;
    background-size: 0.9rem 0.9rem;
  }

  .callout-title {
    display: flex
  }
    
  .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  .callout.no-icon::before {
    display: none !important;
  }

  .callout.callout-titled .callout-body > .callout-content > :last-child {
    margin-bottom: 0.5rem;
  }

  .callout.callout-titled .callout-icon::before {
    margin-top: .5rem;
    padding-right: .5rem;
  }

  .callout:not(.callout-titled) .callout-icon::before {
    margin-top: 1rem;
    padding-right: .5rem;
  }

  /* Callout Types */

  div.callout-note {
    border-left-color: #4582ec !important;
  }

  div.callout-note .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEU0lEQVRYCcVXTWhcVRQ+586kSUMMxkyaElstCto2SIhitS5Ek8xUKV2poatCcVHtUlFQk8mbaaziwpWgglJwVaquitBOfhQXFlqlzSJpFSpIYyXNjBNiTCck7x2/8/LeNDOZxDuEkgOXe++553zfefee+/OYLOXFk3+1LLrRdiO81yNqZ6K9cG0P3MeFaMIQjXssE8Z1JzLO9ls20MBZX7oG8w9GxB0goaPrW5aNMp1yOZIa7Wv6o2ykpLtmAPs/vrG14Z+6d4jpbSKuhdcSyq9wGMPXjonwmESXrriLzFGOdDBLB8Y6MNYBu0dRokSygMA/mrun8MGFN3behm6VVAwg4WR3i6FvYK1T7MHo9BK7ydH+1uurECoouk5MPRyVSBrBHMYwVobG2aOXM07sWrn5qgB60rc6mcwIDJtQrnrEr44kmy+UO9r0u9O5/YbkS9juQckLed3DyW2XV/qWBBB3ptvI8EUY3I9p/67OW+g967TNr3Sotn3IuVlfMLVnsBwH4fsnebJvyGm5GeIUA3jljERmrv49SizPYuq+z7c2H/jlGC+Ghhupn/hcapqmcudB9jwJ/3jvnvu6vu5lVzF1fXyZuZZ7U8nRmVzytvT+H3kilYvH09mLWrQdwFSsFEsxFVs5fK7A0g8gMZjbif4ACpKbjv7gNGaD8bUrlk8x+KRflttr22JEMRUbTUwwDQScyzPgedQHZT0xnx7ujw2jfVfExwYHwOsDTjLdJ2ebmeQIlJ7neo41s/DrsL3kl+W2lWvAga0tR3zueGr6GL78M3ifH0rGXrBC2aAR8uYcIA5gwV8zIE8onoh8u0Fca/ciF7j1uOzEnqcIm59sEXoGc0+z6+H45V1CvAvHcD7THztu669cnp+L0okAeIc6zjbM/24LgGM1gZk7jnRu1aQWoU9sfUOuhrmtaPIO3YY1KLLWZaEO5TKUbMY5zx8W9UJ6elpLwKXbsaZ4EFl7B4bMtDv0iRipKoDQT2sNQI9b1utXFdYisi+wzZ/ri/1m7QfDgEuvgUUEIJPq3DhX/5DWNqIXDOweC2wvIR90Oq3lDpdMIgD2r0dXvGdsEW5H6x6HLRJYU7C69VefO1x8Gde1ZFSJLfWS1jbCnhtOPxmpfv2LXOA2Xk2tvnwKKPFuZ/oRmwBwqRQDcKNeVQkYcOjtWVBuM/JuYw5b6isojIkYxyYAFn5K7ZBF10fea52y8QltAg6jnMqNHFBmGkQ1j+U43HMi2xMar1Nv0zGsf1s8nUsmUtPOOrbFIR8bHFDMB5zL13Gmr/kGlCkUzedTzzmzsaJXhYawnA3UmARpiYj5ooJZiUoxFRtK3X6pgNPv+IZVPcnwbOl6f+aBaO1CNvPW9n9LmCp01nuSaTRF2YxHqZ8DYQT6WsXT+RD6eUztwYLZ8rM+rcPxamv1VQzFUkzFXvkiVrySGQgJNvXHJAxiU3/NwiC03rSf05VBaPtu/Z7/B8Yn/w7eguloAAAAAElFTkSuQmCC');
  }

  div.callout-note.callout-style-default .callout-title {
    background-color: #dae6fb
  }

  div.callout-important {
    border-left-color: #d9534f !important;
  }

  div.callout-important .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAEKklEQVRYCcVXTWhcVRS+575MJym48A+hSRFr00ySRQhURRfd2HYjk2SSTokuBCkU2o0LoSKKraKIBTcuFCoidGFD08nkBzdREbpQ1EDNIv8qSGMFUboImMSZd4/f9zJv8ibJMC8xJQfO3HPPPef7zrvvvnvviIkpC9nsw0UttFunbUhpFzFtarSd6WJkStVMw5xyVqYTvkwfzuf/5FgtkVoB0729j1rjXwThS7Vio+Mo6DNnvLfahoZ+i/o32lULuJ3NNiz7q6+pyAUkJaFF6JwaM2lUJlV0MlnQn5aTRbEu0SEqHUa0A4AdiGuB1kFXRfVyg5d87+Dg4DL6m2TLAub60ilj7A1Ec4odSAc8X95sHh7+ZRPCFo6Fnp7HfU/fBng/hi10CjCnWnJjsxvDNxWw0NfV6Rv5GgP3I3jGWXumdTD/3cbEOP2ZbOZp69yniG3FQ9z1jD7bnBu9Fc2tKGC2q+uAJOQHBDRiZX1x36o7fWBs7J9ownbtO+n0/qWkvW7UPIfc37WgT6ZGR++EOJyeQDSb9UB+DZ1G6DdLDzyS+b/kBCYGsYgJbSQHuThGKRcw5xdeQf8YdNHsc6ePXrlSYMBuSIAFTGAtQo+VuALo4BX83N190NWZWbynBjhOHsmNfFWLeL6v+ynsA58zDvvAC8j5PkbOcXCMg2PZFk3q8MjI7WAG/Dp9AwP7jdGBOOQkAvlFUB+irtm16I1Zw9YBcpGTGXYmk3kQIC/Cds55l+iMI3jqhjAuaoe+am2Jw5GT3Nbz3CkE12NavmzN5+erJW7046n/CH1RO/RVa8lBLozXk9uqykkGAyRXLWlLv5jyp4RFsG5vGVzpDLnIjTWgnRy2Rr+tDKvRc7Y8AyZq10jj8DqXdnIRNtFZb+t/ZRtXcDiVnzpqx8mPcDWxgARUqx0W1QB9MeUZiNrV4qP+Ehc+BpNgATsTX8ozYKL2NtFYAHc84fG7ndxUPr+AR/iQSns7uSUufAymwDOb2+NjK27lEFocm/EE2WpyIy/Hi66MWuMKJn8RvxIcj87IM5Vh9663ziW36kR0HNenXuxmfaD8JC7tfKbrhFr7LiZCrMjrzTeGx+PmkosrkNzW94ObzwocJ7A1HokLolY+AvkTiD/q1H0cN48c5EL8Crkttsa/AXQVDmutfyku0E7jShx49XqV3MFK8IryDhYVbj7Sj2P2eBxwcXoe8T8idsKKPRcnZw1b+slFTubwUwhktrfnAt7J++jwQtLZcm3sr9LQrjRzz6cfMv9aLvgmnAGvpoaGLxM4mAEaLV7iAzQ3oU0IvD5x9ix3yF2RAAuYAOO2f7PEFWCXZ4C9Pb2UsgDeVnFSpbFK7/IWu7TPTvBqzbGdCHOJQSxiEjt6IyZmxQyEJHv6xyQsYk//moVFsN2zP6fRImjfq7/n/wFDguUQFNEwugAAAABJRU5ErkJggg==');
  }

  div.callout-important.callout-style-default .callout-title {
    background-color: #f7dddc
  }

  div.callout-warning {
    border-left-color: #f0ad4e !important;
  }

  div.callout-warning .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAAETklEQVRYCeVWW2gcVRg+58yaTUnizqbipZeX4uWhBEniBaoUX1Ioze52t7sRq6APio9V9MEaoWlVsFasRq0gltaAPuxms8lu0gcviE/FFOstVbSIxgcv6SU7EZqmdc7v9+9mJtNks51NTUH84ed889/PP+cmxP+d5FIbMJmNbpREu4WUkiTtCicKny0l1pIKmBzovF2S+hIJHX8iEu3hZJ5lNZGqyRrGSIQpq15AzF28jgpeY6yk6GVdrfFqdrD6Iw+QlB8g0YS2g7dyQmXM/IDhBhT0UCiRf59lfqmmDvzRt6kByV/m4JjtzuaujMUM2c5Z2d6JdKrRb3K2q6mA+oYVz8JnDdKPmmNthzkAk/lN63sYPgevrguc72aZX/L9C6x09GYyxBgCX4NlvyGUHOKELlm5rXeR1kchuChJt4SSwyddZRXgvwMGvYo4QSlk3/zkHD8UHxwVJA6zjZZqP8v8kK8OWLnIZtLyCAJagYC4rTGW/9Pqj92N/c+LUaAj27movwbi19tk/whRCIE7Q9vyI6yvRpftAKVTdUjOW40X3h5OXsKCdmFcx0xlLJoSuQngnrJe7Kcjm4OMq9FlC7CMmScQANuNvjfP3PjGXDBaUQmbp296S5L4DrpbrHN1T87ZVEZVCzg1FF0Ft+dKrlLukI+/c9ENo+TvlTDbYFvuKPtQ9+l052rXrgKoWkDAFnvh0wTOmYn8R5f4k/jN/fZiCM1tQx9jQQ4ANhqG4hiL0qIFTGViG9DKB7GYzgubnpofgYRwO+DFjh0Zin2m4b/97EDkXkc+f6xYAPX0KK2I/7fUQuwzuwo/L3AkcjugPNixC8cHf0FyPjWlItmLxWw4Ou9YsQCr5fijMGoD/zpdRy95HRysyXA74MWOnscpO4j2y3HAVisw85hX5+AFBRSHt4ShfLFkIMXTqyKFc46xdzQM6XbAi702a7sy04J0+feReMFKp5q9esYLCqAZYw/k14E/xcLLsFElaornTuJB0svMuJINy8xkIYuL+xPAlWRceH6+HX7THJ0djLUom46zREu7tTkxwmf/FdOZ/sh6Q8qvEAiHpm4PJ4a/doJe0gH1t+aHRgCzOvBvJedEK5OFE5jpm4AGP2a8Dxe3gGJ/pAutug9Gp6he92CsSsWBaEcxGx0FHytmIpuqGkOpldqNYQK8cSoXvd+xLxXADw0kf6UkJNFtdo5MOgaLjiQOQHcn+A6h5NuL2s0qsC2LOM75PcF3yr5STuBSAcGG+meA14K/CI21HcS4LBT6tv0QAh8Dr5l93AhZzG5ZJ4VxAqdZUEl9z7WJ4aN+svMvwHHL21UKTd1mqvChH7/Za5xzXBBKrUcB0TQ+Ulgkfbi/H/YT5EptrGzsEK7tR1B7ln9BBwckYfMiuSqklSznIuoIIOM42MQO+QnduCoFCI0bpkzjCjddHPN/F+2Yu+sd9bKNpVwHhbS3LluK/0zgfwD0xYI5dXuzlQAAAABJRU5ErkJggg==');
  }

  div.callout-warning.callout-style-default .callout-title {
    background-color: #fcefdc
  }

  div.callout-tip {
    border-left-color: #02b875 !important;
  }

  div.callout-tip .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAADr0lEQVRYCe1XTWgTQRj9ZjZV8a9SPIkKgj8I1bMHsUWrqYLVg4Ue6v9BwZOxSYsIerFao7UiUryIqJcqgtpimhbBXoSCVxUFe9CTiogUrUp2Pt+3aUI2u5vdNh4dmMzOzHvvezuz8xNFM0mjnbXaNu1MvFWRXkXEyE6aYOYJpdW4IXuA4r0fo8qqSMDBU0v1HJUgVieAXxzCsdE/YJTdFcVIZQNMyhruOMJKXYFoLfIfIvVIMWdsrd+Rpd86ZmyzzjJmLStqRn0v8lzkb4rVIXvnpScOJuAn2ACC65FkPzEdEy4TPWRLJ2h7z4cArXzzaOdKlbOvKKX25Wl00jSnrwVxAg3o4dRxhO13RBSdNvH0xSARv3adTXbBdTf64IWO2vH0LT+cv4GR1DJt+DUItaQogeBX/chhbTBxEiZ6gftlDNXTrvT7co4ub5A6gp9HIcHvzTa46OS5fBeP87Qm0fQkr4FsYgVQ7Qg+ZayaDg9jhg1GkWj8RG6lkeSacrrHgDaxdoBiZPg+NXV/KifMuB6//JmYH4CntVEHy/keA6x4h4CU5oFy8GzrBS18cLJMXcljAKB6INjWsRcuZBWVaS3GDrqB7rdapVIeA+isQ57Eev9eCqzqOa81CY05VLd6SamW2wA2H3SiTbnbSxmzfp7WtKZkqy4mdyAlGx7ennghYf8voqp9cLSgKdqNfa6RdRsAAkPwRuJZNbpByn+RrJi1RXTwdi8RQF6ymDwGMAtZ6TVE+4uoKh+MYkcLsT0Hk8eAienbiGdjJHZTpmNjlbFJNKDVAp2fJlYju6IreQxQ08UJDNYdoLSl6AadO+fFuCQqVMB1NJwPm69T04Wv5WhfcWyfXQB+wXRs1pt+nCknRa0LVzSA/2B+a9+zQJadb7IyyV24YAxKp2Jqs3emZTuNnKxsah+uabKbMk7CbTgJx/zIgQYErIeTKRQ9yD9wxVof5YolPHqaWo7TD6tJlh7jQnK5z2n3+fGdggIOx2kaa2YI9QWarc5Ce1ipNWMKeSG4DysFF52KBmTNMmn5HqCFkwy34rDg05gDwgH3bBi+sgFhN/e8QvRn8kbamCOhgrZ9GJhFDgfcMHzFb6BAtjKpFhzTjwv1KCVuxHvCbsSiEz4CANnj84cwHdFXAbAOJ4LTSAawGWFn5tDhLMYz6nWeU2wJfIhmIJBefcd/A5FWQWGgrWzyORZ3Q6HuV+Jf0Bj+BTX69fm1zWgK7By1YTXchFDORywnfQ7GpzOo6S+qECrsx2ifVQAAAABJRU5ErkJggg==');
  }

  div.callout-tip.callout-style-default .callout-title {
    background-color: #ccf1e3
  }

  div.callout-caution {
    border-left-color: #fd7e14 !important;
  }

  div.callout-caution .callout-icon::before {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAIKADAAQAAAABAAAAIAAAAACshmLzAAACV0lEQVRYCdVWzWoUQRCuqp2ICBLJXgITZL1EfQDBW/bkzUMUD7klD+ATSHBEfAIfQO+iXsWDxJsHL96EHAwhgzlkg8nBg25XWb0zIb0zs9muYYWkoKeru+vn664fBqElyZNuyh167NXJ8Ut8McjbmEraKHkd7uAnAFku+VWdb3reSmRV8PKSLfZ0Gjn3a6Xlcq9YGb6tADjn+lUfTXtVmaZ1KwBIvFI11rRXlWlatwIAAv2asaa9mlB9wwygiDX26qaw1yYPzFXg2N1GgG0FMF8Oj+VIx7E/03lHx8UhvYyNZLN7BwSPgekXXLribw7w5/c8EF+DBK5idvDVYtEEwMeYefjjLAdEyQ3M9nfOkgnPTEkYU+sxMq0BxNR6jExrAI31H1rzvLEfRIdgcv1XEdj6QTQAS2wtstEALLG1yEZ3QhH6oDX7ExBSFEkFINXH98NTrme5IOaaA7kIfiu2L8A3qhH9zRbukdCqdsA98TdElyeMe5BI8Rs2xHRIsoTSSVFfCFCWGPn9XHb4cdobRIWABNf0add9jakDjQJpJ1bTXOJXnnRXHRf+dNL1ZV1MBRCXhMbaHqGI1JkKIL7+i8uffuP6wVQAzO7+qVEbF6NbS0LJureYcWXUUhH66nLR5rYmva+2tjRFtojkM2aD76HEGAD3tPtKM309FJg5j/K682ywcWJ3PASCcycH/22u+Bh7Aa0ehM2Fu4z0SAE81HF9RkB21c5bEn4Dzw+/qNOyXr3DCTQDMBOdhi4nAgiFDGCinIa2owCEChUwD8qzd03PG+qdW/4fDzjUMcE1ZpIAAAAASUVORK5CYII=');
  }

  div.callout-caution.callout-style-default .callout-title {
    background-color: #ffe5d0
  }

  </style>
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
  
    <link rel="icon" href="../Intro2DS_logo.jpg" type="image/jpg"> 
    <link rel="shortcut icon" href="../Intro2DS_logo.jpg" type="image/jpg">
    <link href="https://fonts.googleapis.com/css?family=Lato:400,700" rel="stylesheet" type="text/css">
  </head>

<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="section" class="slide level2 logo-slide">
    <h2></h2>
    </section>
<section id="introduction-to-data-science" class="slide level2 title-slide center">
<h2>Introduction to Data Science</h2>
<h3 id="ensemble-methods-random-forest-and-boosting---class-11">Ensemble Methods: Random Forest and Boosting - Class 11</h3>
<h3 id="giora-simchoni">Giora Simchoni</h3>
<h4 id="gsimchonigmail.com-and-add-intro2ds-in-subject"><code>gsimchoni@gmail.com</code> and add <code>#intro2ds</code> in subject</h4>
<h3 id="stat.-and-or-department-tau">Stat. and OR Department, TAU</h3>
<aside class="notes">
<div style="direction:rtl; font-size:16px">

</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="random-forest" class="slide level2 title-slide center">
<h2>Random Forest</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">

</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="ensemble-methods-using-trees-as-subroutines">Ensemble methods: using trees as subroutines</h3>
<p>Instead of a single tree being a model, combine many trees into a model:</p>
<ol type="1">
<li>Bagging and Random Forest: Fit different trees to the data and average them</li>
<li>Boosting: Adaptively build a model from adding more and more trees</li>
</ol>
<div class="fragment">
<ul>
<li><p>We will focus now on Random Forest (also Bagging), later discuss boosting</p></li>
<li><p>Main idea of Random Forest: Take advantage of the instability and high variance of the trees</p></li>
<li><p>Trees are unstable and greedy: if we change the data a little bit, the tree can change a lot</p></li>
<li><p>Now we intentionally change (randomize) the data to get a different tree every time, and average them</p></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ביחידה הזאת נלמד על שיטות אנסמבל, שעושות קומבינציה של מודלים חלשים רבים, למודל חזק במיוחד. אמרנו כבר כשלמדנו על עצי החלטה שהם מודלים מוגבלים עם שונות גבוהה, ושאלנו את עצמנו – למה עץ אחד? למה לא יער?</p>
<p>נראה היום שתי שיטות אנסמבל מבוססות עצים. הראשונה רנדום פורסט, שמבוססת על מיצוע של הרבה עצים שונים, והשנייה בוסטינג שבה אנחנו בונים עץ אחרי עץ בצורה אדפטיבית.</p>
<p>נתחיל ברנדום פורסט. במקום להתאים עץ אחד לנתונים, אנחנו נתאים הרבה. אבל לא נתאים אותם לאותם הנתונים, אחרת אין הבדל. נתאים אותם כל פעם על דאטא קצת אחר, דאטא שעבר רנדומיזציה, בשתי דרכים שונות. לבסוף נמצע את העצים – החיזוי לכל תצפית יהיה ממוצע שלה על פני הרבה עצים, ונראה שכך נטפל באופן ישיר בבעיות של העץ היחיד.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="reminder-the-value-of-averaging">Reminder: the value of averaging</h3>
<ul>
<li><p>This is captured through different things we learned: CLT, LLN, variance of the average…</p></li>
<li><p>Assume <span class="math inline">\(z_i \sim F\)</span> has some distribution with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span></p></li>
<li><p>If <span class="math inline">\(z_1,\dots,z_m \sim F\)</span> are independent, then <span class="math inline">\(Var(\bar{z}) = \sigma^2 / m\)</span>, so <span class="math inline">\(\bar{z}\)</span> is close to <span class="math inline">\(\mu\)</span> for large <span class="math inline">\(m\)</span></p></li>
</ul>
<div>
<ul>
<li class="fragment"><p>What if <span class="math inline">\(z_1,\dots,z_m\)</span> are dependent?</p></li>
<li class="fragment"><p>Slightly more complex setting: assume <span class="math inline">\(z_1,\dots,z_m\)</span> are <em>somewhat</em> dependent <span class="math inline">\(Cov(z_i,z_j) = \rho \sigma^2,\;\rho&lt;1\)</span></p></li>
<li class="fragment"><p>Now we still get some variance reduction from averaging: <span class="math display">\[Var(\bar{z}) \approx \rho\sigma^2 + (1-\rho)\sigma^2/ m\]</span></p></li>
<li class="fragment"><p>This is exactly the intuition behind Random Forest</p></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ניזכר בערך המיצוע. מה מיצוע נותן לנו? נתקלנו בזה בעבר, כשדיברנו על משפט הגבול המרכזי. אם משתנה מקרי Z_i, מתפלג לפי איזושהי התפלגות F עם תוחלת מיו ושונות סיגמא בריבוע, ואני לוקח m תצפיות כאלה בלתי תלויות, אז השונות של ממוצע המדגם המקרי קטנה פי m. כלומר ככל שm גדול כך הפיזור סביב הממוצע קטן והוא מתקרב לתוחלת האמיתית מיו.</p>
<p>ונניח שהתצפיות הן לא בלתי תלויות. לא רק שהן לא בלתי תלויות, הן תלויות לחלוטין, הן אותה תצפית בדיוק, שחוזרת על עצמה m פעמים. מה יהיה אז הממוצע? התצפית עצמה כמובן. והאם הקטנו את השונות של ההתפלגות המקורית? בכלל לא, נישאר עם השונות המקורית סיגמא בריבוע. כלומר יש כאן איזשהו טווח מתצפיות בלתי תלויות לחלוטין ועד תצפיות תלויות לחלוטין, וההקטנה של סיגמא בריבוע בהתאם.</p>
<p>נסתכל על מצב ביניים, שהתצפיות לא בלתי תלויות לחלוטין אבל גם לא חוזרות על עצמן, המתאם בין זוג תצפיות הוא איזשהו רו שקטן מ1, כלומר הקווריאנס יהיה סיגמא בריבוע כפול רו.</p>
<p>אפשר לראות שכעת שונות ממוצע המדגם היא בקירוב רו סיגמא בריבוע, ועוד 1 מינוס רו כפול סיגמא בריבוע חלקי m. זאת אומרת כשרו שווה ל1, תלות מושלמת, אנחנו נשארים עם סיגמא בריבוע השונות המקורית, וכשרו שווה לאפס, שזה אומר תצפיות בלתי תלויות, נקבל את סיגמא בריבוע חלקי m, שונות מדגם מקרי המוכרת לנו.</p>
<p>זו האינטואיציה שמסבירה למה רנדום פורסט עובד. אם נצליח לקחת עוד ועוד דגימות עם כמה שפחות תלות - במקרה שלנו עוד ועוד עצים, נקטין את השונות המקורית של כל אחת מהן עד פי m. אם הדגימות שלי תלויות חזק אחת בשניה, הרווח שלי מוגבל מפעולת המיצוע. נרצה אם ככה לייצר עצים שיהיו שונים כמה שיותר אחד מהשני כך שנרוויח מהמיצוע שלהם.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="random-forest-algorithm">Random forest algorithm</h3>
<ul>
<li>Repeat many times:</li>
</ul>
<ol type="1">
<li>Randomize the data (by taking a subsample or a <strong>bootstrap</strong> sample)</li>
<li>Build a tree on the randomized data, also randomize tree building (e.g.&nbsp;by randomly choosing variables to consider at each node)</li>
</ol>
<div class="fragment">
<ul>
<li>To predict at new <span class="math inline">\(x_0\)</span>, apply each tree and average their predictions</li>
</ul>
</div>
<div class="fragment">
<ul>
<li>Intuition: trees are different because of randomization, they are like <span class="math inline">\(z_1,...z_n \stackrel{\cdot}{\sim} P(y|x_0)\)</span></li>
</ul>
<ol type="1">
<li>Related (<span class="math inline">\(\rho &gt; 0\)</span>) because it’s the same training set <span class="math inline">\(T\)</span></li>
<li>Still different from each other (<span class="math inline">\(\rho &lt; 1\)</span>) because of randomization and instability of trees</li>
</ol>
</div>
<div class="fragment">
<ul>
<li>Hence we expect (and indeed see!) that Random Forest gives more accurate predictions of <span class="math inline">\(E(y|x)\)</span> or <span class="math inline">\(P(y=1|x)\)</span> than single trees</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז איך נשיג את היער עצים הזה ששונים זה מזה כמה שיותר?</p>
<p>נזריק רנדומיזציה לתהליך: כל עץ יראה דאטא קצת אחר, נהוג לקחת רק חלק מהנתונים, subsample, או מדגם בוטסטראפ, שזה מדגם בגודל m המקורי, עם החזרה. דבר שני שנעשה, תוך כדי בנית העצים על הדאטא הזה, זה בכל צומת נגריל מספר מסוים של משתנים שיהיו מועמדים לפיצול. כלומר אם בעץ המקורי בכל צומת הוא מתחשב בכל המשתנים האפשריים, העצים שלנו עשויים לראות בכל צומת משתנים אחרים לחלוטין.</p>
<p>כעת מגיעה תצפית חדשה לחיזוי. מה זה אומר למצע עצים? זה אומר שנריץ אותה בכל העצים, והחיזוי הסופי שלה יהיה הממוצע שלהם.</p>
<p>על האינטואיציה דיברנו בהרחבה, העצים הם כמו תצפיות ממדגם. הם לא יכולים להיות לגמרי בלתי תלויים כי הם בכל זאת מבוססים על אותו דאטא. אבל נדאג שיהיו כמה שפחות תלויים אחד בשני.</p>
<p>וככה נרוויח מהמיצוע שלהם.</p>
<p>אילו עצים נגדל? עמוקים או שטוחים? עמוקים כמובן! עצים עמוקים שמסוגלים לתאר יחסים מורכבים כמה שניתן. לעצים כאלה תהיה שונות גבוהה שנקטין עם המיצוע. אם נבחר בעצים שטוחים יותר, נתחיל אולי בטעות פחות גבוהה אבל גם לא נרוויח מספיק מהמיצוע. למה שלא נראה את רנדום פורסט בפעולה על הנתונים שלנו.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="rf-in-action" class="slide level2 title-slide center">
<h2>RF in Action</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">

</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="rf-for-netflix-regression">RF for Netflix (Regression)</h3>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1" data-code-line-numbers="|1|7|10-12|13-14|15-16|"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestRegressor</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>ntr <span class="op">=</span> NE_Xtr.shape[<span class="dv">0</span>]</span>
<span id="cb1-4"><a href="#cb1-4"></a>nte <span class="op">=</span> NE_Xte.shape[<span class="dv">0</span>]</span>
<span id="cb1-5"><a href="#cb1-5"></a>tr_err <span class="op">=</span> []</span>
<span id="cb1-6"><a href="#cb1-6"></a>te_err <span class="op">=</span> []</span>
<span id="cb1-7"><a href="#cb1-7"></a>ntrees <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>]</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="cf">for</span> ntree <span class="kw">in</span> ntrees: </span>
<span id="cb1-10"><a href="#cb1-10"></a>    RF <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span>ntree, min_samples_split<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb1-11"><a href="#cb1-11"></a>        min_samples_leaf<span class="op">=</span><span class="dv">1</span>, max_features<span class="op">=</span><span class="fl">0.33</span>,  bootstrap<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-12"><a href="#cb1-12"></a>    RF <span class="op">=</span> RF.fit(NE_Xtr, NE_Ytr)</span>
<span id="cb1-13"><a href="#cb1-13"></a>    yhat_tr <span class="op">=</span> RF.predict(NE_Xtr)</span>
<span id="cb1-14"><a href="#cb1-14"></a>    yhat <span class="op">=</span> RF.predict(NE_Xte)</span>
<span id="cb1-15"><a href="#cb1-15"></a>    tr_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_tr <span class="op">-</span> NE_Ytr)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> ntr))</span>
<span id="cb1-16"><a href="#cb1-16"></a>    te_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat <span class="op">-</span> NE_Yte)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> nte))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נראה את רנדום פורסט על נתוני נטפליקס. הקלאס בשביל רגרסיה נקרא RandomForestRegressor. נגדיל את מספר העצים מאחד ועד אלף. בכל איטרציה נגדל ntree עצים, מאוד עמוקים. נדאג שיהיו מאוד עמוקים במיוחד על-ידי זה שנפרט עם הפרמטר min_samples_split שהמינימום תצפיות לביצוע ספליט הוא קטן, אפשר לבצע ספליט אפילו על שתי תצפיות. עוד פרמטר שכדאי להזכיר הוא הmax_features, ששולט על כמה משתנים יהיו מועמדים בכל פיצול, כאן אנחנו מזינים 0.33 כלומר מדגם של שליש מהמשתנים. אפשר גם להזין מספר שלם כלשהו, ברירת המחדל הוא לקחת את שורש מספר המשתנים. לבסוף נחזה על מדגם הטריין והטסט ונשרשר את הRMSE לרשימה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">4</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> fig.add_subplot(<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">1</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>ax.set_xscale(<span class="st">'log'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>plt.plot(ntrees, tr_err, color<span class="op">=</span><span class="st">'darkorange'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'train'</span> )</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>plt.plot(ntrees, te_err, color<span class="op">=</span><span class="st">'navy'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'test'</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="fl">0.3</span>, <span class="fl">1.3</span>])</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Number trees'</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'RMSE'</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'RF on Netflix'</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>plt.show() </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img data-src="c11_ensemble_methods_files/figure-revealjs/cell-4-output-1.png" width="366" height="377"></p>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כשאנחנו מציירים את הטריין והטסט ארור כנגד מספר העצים אנחנו רואים שמעט עצים עמוקים מגיעים לשגיאה די גבוהה על הטסט, יותר מ1. אלף עצים לעומת זאת מגיעים כבר לאיזור ה0.8. הדבר הכי מעניין אולי בגרף הזה זה ששגיאת החיזוי לא עולה שוב, היא לא מתדרדרת, ואנחנו יודעים בדיוק למה, השונות יכולה רק לקטון. כך שעוד יתרון של רנדום פורסט הוא שאין התלבטות לגבי מספר העצים, אנחנו מוגבלים רק על ידי כוח החישוב שלנו וגודל המודל הסופי על הדיסק, ככל שנאפשר יותר עצים נצפה לשגיאה קטנה יותר. ברור שמאיזשהו מספר עצים כמו שרואים כאן לא בטוח שיש לאן לרדת.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h4 id="lets-try-it-bravely-on-the-full-99-dimensions">Let’s try it bravely on the full 99 dimensions!</h4>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.tree <span class="im">import</span> DecisionTreeRegressor</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ratings[np.isnan(ratings)] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>NE_Xtr_noNAN, NE_Xte_noNAN <span class="op">=</span> train_test_split(ratings, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>A single tree can only get you so far:</p>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ננסה לעבוד עם כל הנתונים שבידינו, כל 99 הסרטים כך שתצפית חסרה היא בעצם דירוג אפס.</p>
<p>נראה קודם מה נותן עץ יחיד.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>tr_err <span class="op">=</span> []</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>te_err <span class="op">=</span> []</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">10</span>, <span class="dv">15</span>]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> depth <span class="kw">in</span> ds:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    Netree <span class="op">=</span> DecisionTreeRegressor(max_depth<span class="op">=</span>depth)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    Netree <span class="op">=</span> Netree.fit(NE_Xtr_noNAN, NE_Ytr)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    yhat_tr <span class="op">=</span> Netree.predict(NE_Xtr_noNAN)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    yhat <span class="op">=</span> Netree.predict(NE_Xte_noNAN)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    tr_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_tr <span class="op">-</span> NE_Ytr)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> ntr))</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    te_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat <span class="op">-</span> NE_Yte)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> nte))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<p><img data-src="c11_ensemble_methods_files/figure-revealjs/cell-7-output-1.png" width="367" height="376"></p>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כאן אנחנו משתמשים בעץ יחיד ופשוט משנים את הmax_depth שלו כמו שעשינו. עם עץ בודד ו14 סרטים הגענו לRMSE של 0.85, כאן אנחנו רואים כבר RMSE של 0.82.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>tr_err <span class="op">=</span> []</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>te_err <span class="op">=</span> []</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>ntrees <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">100</span>, <span class="dv">500</span>, <span class="dv">1000</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ntree <span class="kw">in</span> ntrees: </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    RF <span class="op">=</span> RandomForestRegressor(n_estimators<span class="op">=</span>ntree, min_samples_split<span class="op">=</span><span class="dv">5</span>,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        min_samples_leaf<span class="op">=</span><span class="dv">2</span>, max_features<span class="op">=</span><span class="dv">10</span>, bootstrap<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    RF <span class="op">=</span> RF.fit(NE_Xtr_noNAN, NE_Ytr)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    yhat_tr <span class="op">=</span> RF.predict(NE_Xtr_noNAN)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    yhat <span class="op">=</span> RF.predict(NE_Xte_noNAN)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    tr_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_tr <span class="op">-</span> NE_Ytr)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> ntr))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    te_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat<span class="op">-</span>NE_Yte)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> nte))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="8">
<div class="cell-output cell-output-display">
<p><img data-src="c11_ensemble_methods_files/figure-revealjs/cell-9-output-1.png" width="366" height="377"></p>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כשאנחנו עושים רנדום פורסט, השגיאה של RMSE על הטסט סט, יורדת כבר לאיזור ה0.78! ושוב אם נסתכל על עץ בודד עמוק, השגיאה שלו גבוהה מאוד, זה רק המיצוע של עצים כאלה שמביא אותנו לתוצאה איכותית.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="summary-of-random-forest">Summary of Random Forest</h3>
<ul>
<li><p>Uses advantages of trees, mitigates their shortcomings</p></li>
<li><p>RF trees should be as different as possible from each other:</p>
<ol type="1">
<li>Uses the high-variance property of trees</li>
<li>Add randomization: subsampling of training data for each tree; randomizations in tree splitting</li>
</ol></li>
<li><p>Add diversity by making trees bigger, control variance by averaging, therefore:</p>
<ol type="1">
<li>Trees should be as big as possible</li>
<li>Should build and average as many of them as computationally possible</li>
</ol></li>
</ul>
<div class="fragment">
<ul>
<li>Great advantages for “big data”: highly parallelizable and (almost) hyperparametr free!</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נסכם: שיטת רנדום פורסט משמרת את הגמישות של עצים תוך כדי שהיא מנסה להפחית את החסרון הכי גדול שלם, הנוקשות והשונות הגדולה שלהם.</p>
<p>אנחנו עושים את העצים כמה שיותר שונים זה מזה, על-ידי מדגמי בוטסטראפ ובחירת משתנים שונים כמועמדים לכל פיצול.</p>
<p>ומלבד זה אנחנו דואגים שהעצים יהיו עמוקים כמה שאפשר, כדי שנרוויח כמה שיותר מאפקט המיצוע, מעץ בודד עם איכות חיזוי גרועה להרבה עם איכות חיזוי טובה.</p>
<p>עקרונית גם אמרנו, שככל שנבנה יותר עצים איכות החיזוי על הטסט סט יכולה רק לקטון, יתרון משמעותי לשיטה, בפועל אנחנו כנראה מוגבלים על-ידי כוח חישוב וגם גודל על הדיסק, כל אחד מהעצים האלה יכול להיות אוביקט די גדול, אלף עצים לשמור על שרתים זה כבר לא סימפטי.</p>
<p>עוד יתרון שאנחנו פחות עוסקים בקורס הזה אבל הוא קריטי: קל למקבל רנדום פורסט על-פני מספר מחשבים? קל מאוד! כל עץ ברנדום פורסט יכול לגדול באופן בלתי תלוי מהאחרים, לכן אם הנתונים גדולים ועומדת לרשות מדען הנתונים סביבת עבודה מבוזרת, קלאסטר של מספר מחשבים, ניתן להגיע לאימון מהיר מאוד של האלגוריתם. ויתרון אחרון שרמזנו עליו - כמעט בכל שיטה שאנחנו לומדים יש היפרפרמטרים, איזשהם כפתורים שצריך לסובב כדי להתאים את האלגוריתם למקרה שלנו, כמו מספר השכנים בKNN או מטריקת המרחק. בסך הכל ברנדום פורסט אין פרמטרים שיש עליהם סימן שאלה, ברור שאנחנו צריכים כמה שיותר עצים וברור שהם צריכים להיות כמה שיותר עמוקים. זה הופך את רנדום פורסט לאלגוריתם אוף-דה-שלף מאוד פופולרי, כי בלי כיוונון אפשר להגיע מהר לתוצאה מצוינת.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="boosting" class="slide level2 title-slide center">
<h2>Boosting</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נדבר כעת על בוסטינג. בוסטינג הוא גם כן אנסמבל של מודלים פשוטים אבל הוא שונה לחלוטין באופן שבו אנחנו מגדלים את התת-מודלים ובאופן שבו אנחנו ממצעים אותם. בוסטינג לא חייב להיות מבוסס על עצים, אבל בפועל זה המימוש הפופולרי ביותר.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="boosting-intuitive-idea">Boosting: intuitive idea</h3>
<ul>
<li><p>We gradually and iteratively build the overall model as a sum of smaller models called <em>weak learners</em></p></li>
<li><p>Each weak learner seeks to improve the model we have so far</p></li>
<li><p>Weak learners can be any predictive model, most widely used: trees</p></li>
<li><p>How do we capture the notion of <em>improve the model we have so far</em>?</p></li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נתחיל ברמה האינטואיטיבית: אנחנו נבנה מודל די מורכב, אבל לא בבת אחת. בהדרגה. נבנה מודל פשוט. ואז נשפר אותו באמצעות מודל פשוט נוסף. ואז נשפר את הביצועים של השניים שיש לנו, עם מודל פשוט שלישי. וכך הלאה. בצורה הזאת יש לי מודל שהוא קומבינציה של הרבה מודלים פשוטים, weak learners, והמודל הזה הוא כבר לא כל כך פשוט.</p>
<p>לדוגמא, עצים. מה הופך עץ למודל “פשוט” או weak learner? אם נעשה אותו לא עמוק, עץ יחסית שטוח. עץ בעומק 1 זה בעצם לשאול שאלה אחת על התצפית, עץ בעומק 2 זה אומר לשאול 2 שאלות, לא יכול להיווצר מזה מודל מורכב.</p>
<p>ואיך זה שונה מרנדום פורסט? ברנדום פורסט הסתכלנו על עצים “חזקים” לא “חלשים”, וכל עץ באופן בלתי תלוי לחלוטין משאר העצים, אמרנו גם שאפשר לגדל אותם במקביל. כאן אי אפשר לעשות את זה, העץ השני יהיה חייב לדעת מה הביצועים של העץ הראשון כדי לשפר אותו.</p>
<p>השאלה העיקרית היא איך נדאג שהמודל הפשוט הבא, העץ השטוח הבא, ישפר את מה שקדם לו?</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="boosting-overall-scheme">Boosting: overall scheme</h3>
<ol type="1">
<li>Initialize <span class="math inline">\(F^{(0)}(x) = 0,\; \forall x\)</span></li>
<li>At stage <span class="math inline">\(t \geq 1\)</span>:<br>
<ol type="a">
<li>Calculate <span class="math inline">\(Y^{(t)} = (y_1^{(t)},\ldots,y_n^{(t)})\)</span> capturing what the model <span class="math inline">\(F^{(t-1)}\)</span> <strong>has not yet explained</strong><br></li>
<li>Fit a weak learner <span class="math inline">\(\hat{f}^{(t)}\)</span> to <span class="math inline">\(T^{(t)} = (X,Y^{(t)})\)</span><br></li>
<li>Update <span class="math inline">\(F^{(t)} = F^{(t-1)} + \epsilon \hat{f}^{(t)}\)</span></li>
</ol></li>
</ol>
<div class="fragment">
<p><strong>Details: How to determine <span class="math inline">\(Y^{(t)}\)</span>? Which weak learner to use? What is <span class="math inline">\(\epsilon\)</span>?</strong></p>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נראה כעת את האלגוריתם של בוסטינג במבט על.</p>
<p>נתחיל בחיזוי F0 בסיסי זהה לכל התצפיות, אפשר לחזות אפס או ממוצע.</p>
<p>כעת בשלב t, נגדיר את הוקטור y_t להיות לא הוקטור המקורי של התצפיות שלנו, אלא וקטור שתופס באיזשהו מובן את מה שהמודל עד כה לא הצליח לתפוס. איך נעשה את זה עוד לא אמרנו. והמודל עד כה הוא יסומן בF_t-1. בשלב t = 1 זה כמובן המודל הלא אינפורמטיבי F0 שבהגדרה חוזה אפס לכל התצפיות.</p>
<p>עכשיו בשלב הt זהו מדגם הלמידה שלנו, מטריצת הX המקורית, והוקטור y_t שאמרנו שתופס את מה שלא הצלחנו למדל עד כה. ועל הדאטא הזה נבנה את העץ הפשוט, הוויק לרנר, f_hat_t. כלומר בשלב הטי העץ הפשוט ינסה להתאים את עצמו כמו שיותר לy_t, לא לy המקורי.</p>
<p>בשלב האחרון, אנחנו מעדכנים את המודל עד כה עם המודל החדש, f_hat_t. המודל החדש Ft יהיה המודל עד שלב t-1, ועוד איזשהו קבוע אפסילון קטן כפול המודל החדש f_hat_t. ברגרסיה הכוונה בעצם לקחת את החיזוי של Y לכל תצפית עד כה ולהוסיף את החיזוי החדש כפול משקולת קטנה.</p>
<p>אז זה המודל בהיי-לבל, נשאלת השאלה באיזה מודל פשוט להשתמש (ואמרנו שנשתמש בעץ שטוח), איך לקבוע את הקבוע אפסילון, אבל הכי מעניין איך להחליט מהו וקטור הy_t שאמור לבטא מה שהמודל עד כה לא הצליח לקלוט. ברגרסיה למשל, יש לנו Y מקורי ו-Y חזוי עד כה. איך נבטא את “מה שהמודל לא הצליח לחזות”? באמצעות השארית!</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="example-tree-boosting-for-regression">Example: Tree boosting for regression</h3>
<ul>
<li><p>Defining <span class="math inline">\(Y^{(t)}\)</span> as <span class="math inline">\(y_i^{(t)} = (y_i - F^{(t-1)}(x_i))\)</span> the current residual (what the model does not explain)</p></li>
<li><p>Weak learner: trees, usually small — two- or three-level trees as <span class="math inline">\(\hat{f}^{(t)}\)</span></p></li>
<li><p>Make <span class="math inline">\(\epsilon\)</span> as small as possible (<span class="math inline">\(\epsilon\)</span>-boosting): tradeoff between accuracy and computation</p></li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אז ברגרסיה באמת וקטור y_t שנמדל בכל שלב t -יהיה השארית: התצפית ה-i פחות החיזוי שלה עד כה F_t-1 על התצפית x_i.</p>
<p>העץ שלנו יהיה בדרך כלל בעומק 2-3, תיכף נדגים כמה זה חשוב.</p>
<p>והאפסילון, נרצה שיהיה כמה שיותר קטן. מדוע? אפשר לראות באפסילון קצב הלמידה שלנו. למדתי מודל, ואני לוקח אותו בערבון מוגבל, אני מוסיף אותו לממוצע עם משקולת קטנה וממשיך הלאה. תיכף נעשה את זה ברור יותר אני מקווה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h4 id="boosted-trees-depth-2">Boosted trees: depth 2</h4>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb6" data-code-line-numbers="|6|7-9|11|12-13|14-15|16-17|20|"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1"></a>ntr <span class="op">=</span> NE_Xtr_noNAN.shape[<span class="dv">0</span>]</span>
<span id="cb6-2"><a href="#cb6-2"></a>nte <span class="op">=</span> NE_Xte_noNAN.shape[<span class="dv">0</span>]</span>
<span id="cb6-3"><a href="#cb6-3"></a>tr_err <span class="op">=</span> []</span>
<span id="cb6-4"><a href="#cb6-4"></a>te_err <span class="op">=</span> []</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a>Ytr_now <span class="op">=</span> NE_Ytr</span>
<span id="cb6-7"><a href="#cb6-7"></a>yhat_tr <span class="op">=</span> np.zeros(ntr)</span>
<span id="cb6-8"><a href="#cb6-8"></a>yhat_te <span class="op">=</span> np.zeros(nte)</span>
<span id="cb6-9"><a href="#cb6-9"></a>eps <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="cf">for</span> iter_num <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">200</span>):</span>
<span id="cb6-12"><a href="#cb6-12"></a>    tree <span class="op">=</span> DecisionTreeRegressor(max_depth <span class="op">=</span> <span class="dv">2</span>)</span>
<span id="cb6-13"><a href="#cb6-13"></a>    tree.fit(NE_Xtr_noNAN, Ytr_now)</span>
<span id="cb6-14"><a href="#cb6-14"></a>    yhat_tr_now <span class="op">=</span> tree.predict(NE_Xtr_noNAN)</span>
<span id="cb6-15"><a href="#cb6-15"></a>    yhat_te_now <span class="op">=</span> tree.predict(NE_Xte_noNAN)</span>
<span id="cb6-16"><a href="#cb6-16"></a>    yhat_tr <span class="op">+=</span> eps <span class="op">*</span> yhat_tr_now</span>
<span id="cb6-17"><a href="#cb6-17"></a>    yhat_te <span class="op">+=</span> eps <span class="op">*</span> yhat_te_now    </span>
<span id="cb6-18"><a href="#cb6-18"></a>    tr_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_tr <span class="op">-</span> NE_Ytr)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> ntr))</span>
<span id="cb6-19"><a href="#cb6-19"></a>    te_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_te <span class="op">-</span> NE_Yte)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> nte))</span>
<span id="cb6-20"><a href="#cb6-20"></a>    Ytr_now <span class="op">=</span> NE_Ytr <span class="op">-</span> yhat_tr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ננסה לממש בוסטינג של עצים לרגרסיה בעצמנו על הנתונים של נטפליקס עם כל 99 הסרטים, סך הכל מדובר במתכון די פשוט. אחר כך נראה את הקלאס הרלוונטי מsklearn.</p>
<p>נקבע את Ytr_now להיות Y הנוכחי.</p>
<p>בתור הוקטור yhat_tr ו-yhat_te נשים אפסים, זה מה שאנחנו חוזים לכל התצפיות בהתחלה. נאתחל גם את אפסילון להיות ערך קטן 0.05.</p>
<p>נחזור על הפרוצדורה שלנו 200 פעם כלומר נבנה 200 עצים.</p>
<p>כל פעם נבנה עץ שטוח בעומק 2, ונמדל לא את Y המקורי אלא את Ytr_now.</p>
<p>נחזה על הטריין ועל הטסט, ואת החיזוי שלנו נוסיף כפול אפסילון לוקטורי החיזוי עד כה.</p>
<p>מה נשאר לנו? לעדכן את Ytr_now, זה צריך להיות השארית בין Y המקורי, לבין הY החזוי עד כה, על מדגם הלמידה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">200</span>), tr_err, color<span class="op">=</span><span class="st">'darkorange'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'train'</span> )</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">200</span>), te_err, color<span class="op">=</span><span class="st">'navy'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'test'</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="fl">0.3</span>, <span class="fl">1.3</span>])</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'iteration'</span>)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'RMSE'</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Tree boosting on Netflix - depth 2'</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>plt.show() </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'test RMSE iter 0: </span><span class="sc">{</span>te_err[<span class="dv">0</span>]<span class="sc">: .2f}</span><span class="ss">, iter 10: </span><span class="sc">{</span>te_err[<span class="dv">10</span>]<span class="sc">:.2f}</span><span class="ss">, iter 100: </span><span class="sc">{</span>te_err[<span class="dv">100</span>]<span class="sc">:.2f}</span><span class="ss">, iter 199: </span><span class="sc">{</span>te_err[<span class="dv">199</span>]<span class="sc">:.2f}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img data-src="c11_ensemble_methods_files/figure-revealjs/cell-11-output-1.png" width="366" height="302"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>test RMSE iter 0:  3.56, iter 10: 2.23, iter 100: 0.78, iter 199: 0.77</code></pre>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כשאנחנו מציירים את טעות החיזוי הRMSE על הטריין ועל הטסט אנחנו רואים כצפוי ירידה ככל שנוספים עוד עצים עד איזושהי אסימפטוטה.</p>
<p>אחרי העץ ה200 כבר רואים RMSE 0.77-0.78 ואנחנו זוכרים שלנתונים האלה זאת תוצאה איכותית מאוד. עוד תופעה מעניינת כאן היא שבניגוד למודלים אחרים שראינו יש הבדל קטן מאוד בין הטריין לטסט בטעות החיזוי. למה זה קורה? זה קורה משום שאנחנו מראש בונים עצים יחסית שטוחים, עצים שלא עושים overfitting לנתונים, לכן המודל הכללי של בוסטינג נוטה לעשות הרבה פחות overfitting.</p>
<p>נקודה אחרונה שהייתי רוצה להדגיש: הרבה חושבים שהעובדה שאפסילון זהה לכל העצים אומרת שאנחנו נותנים משקל זהה לכולם. קודם כל יש גירסאות לבוסטינג בהן נשתמש באפסילון שונה, כמו בכל אופטימיזציה ניתן לבחור את קצב הלמידה בצורה אדפטיבית. אבל אפילו אם הוא זהה, האם באמת מדובר במשקולת שווה לכל העצים? לא ממש. כי העץ הראשון יחזה כמות יחסית גדולה, את Y המקורי, וכל עץ שיבוא אחריו יחזה שארית שתלך ותיעשה קטנה יותר. אז אולי כל עץ מוכפל פי אפסילון אבל ההשפעה שלהם במודל הגדול שונה לגמרי, העצים הראשונים ישפיעו הרבה יותר על החיזוי מהעץ ה200.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h4 id="boosted-trees-depth-3">Boosted trees: depth 3</h4>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb9" data-code-line-numbers="|11|"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1"></a>tr_err <span class="op">=</span> []</span>
<span id="cb9-2"><a href="#cb9-2"></a>te_err <span class="op">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a>Ytr_now <span class="op">=</span> NE_Ytr</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a>yhat_tr <span class="op">=</span> np.zeros(ntr)</span>
<span id="cb9-7"><a href="#cb9-7"></a>yhat_te <span class="op">=</span> np.zeros(nte)</span>
<span id="cb9-8"><a href="#cb9-8"></a>eps <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="cf">for</span> iter_num <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">200</span>):</span>
<span id="cb9-11"><a href="#cb9-11"></a>    tree <span class="op">=</span> DecisionTreeRegressor(max_depth <span class="op">=</span> <span class="dv">3</span>)</span>
<span id="cb9-12"><a href="#cb9-12"></a>    tree.fit(NE_Xtr_noNAN, Ytr_now)</span>
<span id="cb9-13"><a href="#cb9-13"></a>    yhat_tr_now <span class="op">=</span> tree.predict(NE_Xtr_noNAN)</span>
<span id="cb9-14"><a href="#cb9-14"></a>    yhat_te_now <span class="op">=</span> tree.predict(NE_Xte_noNAN)</span>
<span id="cb9-15"><a href="#cb9-15"></a>    yhat_tr <span class="op">+=</span> eps <span class="op">*</span> yhat_tr_now</span>
<span id="cb9-16"><a href="#cb9-16"></a>    yhat_te <span class="op">+=</span> eps <span class="op">*</span> yhat_te_now    </span>
<span id="cb9-17"><a href="#cb9-17"></a>    tr_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_tr <span class="op">-</span> NE_Ytr)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> ntr))</span>
<span id="cb9-18"><a href="#cb9-18"></a>    te_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_te <span class="op">-</span> NE_Yte)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> nte))</span>
<span id="cb9-19"><a href="#cb9-19"></a>    Ytr_now <span class="op">=</span> NE_Ytr <span class="op">-</span> yhat_tr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>מהו ה”כפתור” העיקרי שלנו כשאנחנו מריצים מודל בוסטינג? עומק העץ. מתבקש לנסות להעמיק כאן את העץ, ההבדל היחיד הוא שאני מנסה עומק מקסימלי של 3. עדיין עצים שטוחים יחסית.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">4</span>,<span class="dv">3</span>))</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">200</span>), tr_err, color<span class="op">=</span><span class="st">'darkorange'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'train'</span> )</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">200</span>), te_err, color<span class="op">=</span><span class="st">'navy'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'test'</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="fl">0.3</span>, <span class="fl">1.3</span>])</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'iteration'</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'RMSE'</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Tree boosting on Netflix - depth 3'</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.show() </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'test RMSE iter 0: </span><span class="sc">{</span>te_err[<span class="dv">0</span>]<span class="sc">: .2f}</span><span class="ss">, iter 10: </span><span class="sc">{</span>te_err[<span class="dv">10</span>]<span class="sc">:.2f}</span><span class="ss">, iter 100: </span><span class="sc">{</span>te_err[<span class="dv">100</span>]<span class="sc">:.2f}</span><span class="ss">, iter 199: </span><span class="sc">{</span>te_err[<span class="dv">199</span>]<span class="sc">:.2f}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img data-src="c11_ensemble_methods_files/figure-revealjs/cell-13-output-1.png" width="366" height="302"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>test RMSE iter 0:  3.56, iter 10: 2.23, iter 100: 0.77, iter 199: 0.77</code></pre>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>זה נראה בהתחלה שאין הבדל בין עומק 2 לעומק 3, אבל אם תשוו את הפרופילים האלה אחד ליד השני תראו שעקומת הטריין עם עומק 3 שונה הרבה יותר מעקומת הטסט, היא נמוכה יותר, כלומר יש יותר אוברפיטינג. מעניין גם שכאן אנחנו מגיעים לתוצאה האיכותית של RMSE 0.77 כבר אחרי 100 עצים.</p>
<p>אז מה יקרה עם נעשה בוסטינג עם עצים של רנדום פורסט, עצים עמוקים מאוד? ננסה!</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h4 id="boosted-trees-depth-15">Boosted trees: depth 15</h4>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb12" data-code-line-numbers="|11|"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1"></a>tr_err <span class="op">=</span> []</span>
<span id="cb12-2"><a href="#cb12-2"></a>te_err <span class="op">=</span> []</span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a>Ytr_now <span class="op">=</span> NE_Ytr</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a>yhat_tr <span class="op">=</span> np.zeros(ntr)</span>
<span id="cb12-7"><a href="#cb12-7"></a>yhat_te <span class="op">=</span> np.zeros(nte)</span>
<span id="cb12-8"><a href="#cb12-8"></a>eps <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="cf">for</span> iter_num <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">100</span>):</span>
<span id="cb12-11"><a href="#cb12-11"></a>    tree <span class="op">=</span> DecisionTreeRegressor(max_depth <span class="op">=</span> <span class="dv">15</span>)</span>
<span id="cb12-12"><a href="#cb12-12"></a>    tree.fit(NE_Xtr_noNAN, Ytr_now)</span>
<span id="cb12-13"><a href="#cb12-13"></a>    yhat_tr_now <span class="op">=</span> tree.predict(NE_Xtr_noNAN)</span>
<span id="cb12-14"><a href="#cb12-14"></a>    yhat_te_now <span class="op">=</span> tree.predict(NE_Xte_noNAN)</span>
<span id="cb12-15"><a href="#cb12-15"></a>    yhat_tr <span class="op">+=</span> eps <span class="op">*</span> yhat_tr_now</span>
<span id="cb12-16"><a href="#cb12-16"></a>    yhat_te <span class="op">+=</span> eps <span class="op">*</span> yhat_te_now    </span>
<span id="cb12-17"><a href="#cb12-17"></a>    tr_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_tr <span class="op">-</span> NE_Ytr)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> ntr))</span>
<span id="cb12-18"><a href="#cb12-18"></a>    te_err.append(np.sqrt(np.<span class="bu">sum</span>((yhat_te <span class="op">-</span> NE_Yte)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> nte))</span>
<span id="cb12-19"><a href="#cb12-19"></a>    Ytr_now <span class="op">=</span> NE_Ytr <span class="op">-</span> yhat_tr</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>כאן אנחנו חוזרים על אותה סימולציה עם עומק מקסימלי 15.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">4</span>, <span class="dv">3</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">100</span>), tr_err, color<span class="op">=</span><span class="st">'darkorange'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'train'</span> )</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>plt.plot(<span class="bu">range</span>(<span class="dv">100</span>), te_err, color<span class="op">=</span><span class="st">'navy'</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">'test'</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="fl">0.3</span>, <span class="fl">1.3</span>])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'iteration'</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'RMSE'</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Tree boosting on Netflix - depth 15'</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>plt.legend(loc<span class="op">=</span><span class="st">"upper right"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>plt.show() </span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'test RMSE iter 0: </span><span class="sc">{</span>te_err[<span class="dv">0</span>]<span class="sc">: .2f}</span><span class="ss">, iter 10: </span><span class="sc">{</span>te_err[<span class="dv">10</span>]<span class="sc">:.2f}</span><span class="ss">, iter 100: </span><span class="sc">{</span>te_err[<span class="dv">99</span>]<span class="sc">:.2f}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img data-src="c11_ensemble_methods_files/figure-revealjs/cell-15-output-1.png" width="368" height="302"></p>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>test RMSE iter 0:  3.56, iter 10: 2.23, iter 100: 0.89</code></pre>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>והנה אנחנו רואים, שבוסטינג עם learners שהם אינם weak לכאורה, זה מודל גרוע. כבר אחרי 100 עצים שגיאת הטסט מגיעה לאסימפטוטה שמייצגת RMSE גרוע, והאוברפיטינג למדגם הטריין הוא פתולוגי. זאת המחשה יפה לתיאוריה שמסבירה למה צריך עצים שטוחים יחסית ולא עמוקים, ואנחנו גם רואים היטב את ההבדל לעומת רנדום פורסט.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="boosting-in-depth" class="slide level2 title-slide center">
<h2>Boosting: in Depth</h2>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ננסה להיכנס קצת יותר לעומק המתמטי של בוסטינג. עד עכשיו תיארנו את המודל ונתנו הרבה אינטואיציה.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="a-more-disciplined-view">A more disciplined view</h3>
<ul>
<li><p>For regression, taking the residual as <span class="math inline">\(y_i^{(t)}\)</span> makes sense</p></li>
<li><p>What is an analogy for classification?</p></li>
<li><p>What about a more rigorous mathematical explanation of what we are doing?</p></li>
<li><p>There are several approaches of varying mathematical complexity for describing and analyzing boosting</p></li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>אמרנו שY בזמן t צריך לייצג את מה שלא הסברנו עד עכשיו. וברגרסיה אינטואיטיבית לקחנו את השארית.</p>
<p>ברגע שאנחנו עוברים לקלספיקציה לא ברור מה זה אומר. אולי לשארית יש מובן עמוק יותר?</p>
<p>יש מספר תיאוריות למה בוסטינג עובד, נראה אחת.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="the-additive-model-view">The additive model view</h3>
<ul>
<li><p>Start with a very large (possibly infinite) set of <span class="math inline">\(q\)</span> candidate “weak learners”: <span class="math inline">\(h_1(x), \dots, h_q(x)\)</span></p></li>
<li><p>We are looking for a “linear” model of the form <span class="math inline">\(\hat{f}(x) = \sum_{k=1}^q \hat{\beta}_k h_k(x)\)</span></p></li>
<li><p>In boosted trees example the <span class="math inline">\(h_k\)</span>’s are <em>all possible trees of the given depth</em></p></li>
<li><p>Since <span class="math inline">\(q\)</span> is huge we cannot directly find a good <span class="math inline">\(\hat{\beta} \in \mathbb{R}^q\)</span></p></li>
</ul>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ננסה לא לחשוב על העצים האלה בעומק 2 שאנחנו מתאימים כמודלים. ננסה לחשוב עליהם כעל פיצ’רים! בדומה לרגרסיה ליניארית או לוגיסטית. נניח שיש q עצים אפשריים כאלה כלומר q פיצ’רים, וברור כבר שq יכול להיות גדול מאוד.</p>
<p>המודל הסופי שלנו, מאוד מזכיר רגרסיה, הוא צירוף ליניארי של העצים או הפיצ’רים האלה: כל אחד מהם מקבל משקולת בטא-האט-קיי, והחיזוי הסופי הוא צירוף ליניארי.</p>
<p>מה הבעיה? העצים האלה לא באמת נתונים, אנחנו לא באמת במצב של רגרסיה ליניארית. ו-q הוא עצום. תחשבו כמה עצים בעומק נתון אפשר לבנות לנתונים כמו נטפליקס למשל. כך שאנחנו לא באמת יכולים למצוא את הוקטור בטא-האט הזה באורך q כפי שאנחנו עושים למשל ברגרסיה ליניארית.</p>
<p>הרעיון הוא למצוא אותו בצורה אדיטיבית, גרידית. לחפש כל פעם את ה”משתנה” הבא, במקרה שלנו עץ, ולהוסיף אותו יחד עם משקולת לצירוף הליניארי.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="additive-model-via-boosting">Additive model via boosting</h3>
<ul>
<li><p>At each iteration <span class="math inline">\(t\)</span> we find a “good” candidate <span class="math inline">\(h_{k_t}\)</span> and add <span class="math inline">\(\epsilon h_{k_t}\)</span> to the current model</p></li>
<li><p>After <span class="math inline">\(T\)</span> iterations we have a model where <span class="math inline">\(\hat{\beta}_k = \epsilon \times \# \{k_t = k\}\)</span> (the number of times <span class="math inline">\(k\)</span> was chosen)</p></li>
</ul>
<div>
<ul>
<li class="fragment"><p>How do we define a good <span class="math inline">\(h_{k_t}\)</span> to update its coefficient?</p></li>
<li class="fragment"><p>One option: given the current model <span class="math inline">\(F^{(t-1)}\)</span>, which <span class="math inline">\(h_k\)</span> improves the model fit the <em>fastest</em> when we add it to the model?</p></li>
<li class="fragment"><p>This can be captured by using the derivative of the loss which measures the fit. Derivative of the RSS (squared loss): <span class="math display">\[\left.\frac{\partial RSS(F^{(t-1)})}{\partial \hat{y}_i}\right|_{\hat{y}_i= F^{(t-1)}(x_i)} = -2 (y_i - F^{(t-1)}(x_i))\]</span></p></li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>במקרה שלנו, בטא כובע הוא האפסילון. כלומר אחרי T איטרציות, בטא-כובע של העץ הספציפי h_k יהיה אפסילון כפול מספר הפעמים שנבחר העץ h_k. אם יש מיליארד עצים אפשריים נניח, רובם לא ייבחרו ויקבלו משקולת בטא-האט אפס, חלקם יקבלו משקולת אפסילון, ואולי מספר עצים בודדים יקבלו אפסילון כפול 2 או 3 כי הם נבחרו 2 או 3 פעמים. אז ברור שזה לא וקטור הבטא-האט שנותן את הצירוף הליניארי הטוב ביותר שניתן להתאים במרחב העצים, זה וקטור בטא-האט שנבנה בצורה אדיטיבית.</p>
<p>ומהו העץ בכל שלב, שנבחר להצטרף לצירוף הליניארי?</p>
<p>זהו העץ שמשפר את המודל הכי הרבה!</p>
<p>ומה זה מודל שמשפר הכי הרבה? זה מודל שכשאני אוסיף אפסילון קטן כפול החיזוי שלו, הפיט שלי ישתפר הכי הרבה. מה זה ישתפר הכי הרבה? יקטין הכי הרבה את הלוס פאנקשן. באיזו לוס פאנקשן אנחנו משתמשים ברגרסיה? הRSS, סכום השגיאות הריבועיות של Y מyhat.</p>
<p>כלומר אנחנו רוצים להקטין פונקציה כמה שיותר, וזה אנחנו בדרך כלל משיגים על-ידי ירידה של צעד קטן במורד הנגזרת של הפונקציה שלנו, במורד הגרדיאנט.</p>
<p>עכשיו הRSS בכל קואורדינטה i הוא הריבוע y פחות החיזוי שלה בריבוע. והנגזרת של זה לפי החיזוי היא מינוס 2, כפול השארית.</p>
<p>המשמעות היא שכל פעם שאנחנו מוסיפים אפסילון כפול המודל שחוזה את השארית הכי טוב, אנחנו בעצם הולכים צעד קטן במורד הגרדיאנט, אנחנו מקטינים את הלוס! זה גם מסביר למה אנחנו קוראים לאפסילון קצב למידה, ולמה אנחנו מעדיפים צעדים קטנים, ככה אנחנו בדרך כלל עושים באופטימיזציה, הולכים בצעדים קטנים.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="the-gradient-boosting-paradigm">The Gradient Boosting Paradigm</h3>
<ul>
<li><p>Choose a loss function for modeling (like RSS for regression)</p></li>
<li><p>At each iteration: calculate the (negative) gradient of the loss function at the current model, use that as <span class="math inline">\(Y^{(t)}\)</span> for the next weak learner</p></li>
<li><p>Interpretation: trying to find a weak learner <span class="math inline">\(h_{k_t}\)</span> which “behaves like” the negative gradient, which is the direction of <em>fastest decrease</em> of the loss</p></li>
</ul>
<div class="fragment">
<ul>
<li>Can be applied with different loss functions for regression or classification (In the HW – classification on wikiart paintings)</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>ואם הבנו את זה אפשר להפעיל את צורת החשיבה הזאת על כל מודל וכל לוס. קח את הלוס שלך ובכל איטרציה תקטין אותו על-ידי שתבחר את הוויק לרנר או העץ שימדל את הגרדיאנט השלילי שלו הכי טוב, ותוסיף אפסילון כפול החיזוי הזה. זה בעצם ללכת צעד אפסילון בכיוון שבו הלוס יורד הכי מהר, כיוון הגרדיאנט.</p>
<p>בקלסיפיקציה אפשר לעשות בדיוק אותו דבר, כל מה שצריך זה לדעת מה הלוס פאנקשן ומה הנגזרת שלה. אם אתם זוכרים שם דיברנו על הנראות כפונקציה שהיינו רוצים לעשות לה מקסימום אז אפשר לחשוב על הנראות השלילית כפונקציה לעשות לה מינימום ולהמשיך משם, עד שמגיעים לביטוי דומה מאוד לשאריות. בpdf המצורף יש הרחבה על הנושא למי שרוצה לקרוא. בכל מקרה, תראו את זה כבר בפעולה בשיעורי הבית על מדגם הציורים שלנו מwikiart.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="boosting-for-netflix-regression">Boosting for Netflix (Regression)</h3>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> GradientBoostingRegressor</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>GBR <span class="op">=</span> GradientBoostingRegressor(loss<span class="op">=</span><span class="st">'squared_error'</span>, learning_rate<span class="op">=</span><span class="fl">0.05</span>,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    n_estimators<span class="op">=</span><span class="dv">200</span>, max_depth<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>GBR.fit(NE_Xtr_noNAN, NE_Ytr)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>yhat_tr <span class="op">=</span> GBR.predict(NE_Xtr_noNAN)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>yhat_te <span class="op">=</span> GBR.predict(NE_Xte_noNAN)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>RMSE_tr <span class="op">=</span> np.sqrt(np.<span class="bu">sum</span>((yhat_tr <span class="op">-</span> NE_Ytr)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> ntr)</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>RMSE_te <span class="op">=</span> np.sqrt(np.<span class="bu">sum</span>((yhat_te <span class="op">-</span> NE_Yte)<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> nte)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'200 trees, depth 3: train RMSE: </span><span class="sc">{</span>RMSE_tr<span class="sc">: .2f}</span><span class="ss">, test RMSE: </span><span class="sc">{</span>RMSE_te<span class="sc">: .2f}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>200 trees, depth 3: train RMSE:  0.71, test RMSE:  0.77</code></pre>
</div>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>בשורה התחתונה, אפשר להשתמש במימוש של sklearn עם הקלאס GradientBoostingRegressor. כאן אני מבקש loss של squared_error, מפרט את הלרנינג-רייט הוא האפסילון שלנו. n_estimators זה מספר העצים ופרמטר הmax_depth כרגיל.</p>
<p>אנחנו מקבלים על מדגם הטסט שגיאת חיזוי דומה מאוד לסימולציה שלנו באופן לא מפתיע.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section class="slide level2">

<h3 id="trees-based-ensembles-rf-vs-boosting">Trees-based Ensembles: RF vs Boosting</h3>
<div class="fragment">
<p>RF: Average trees which are <em>as different as possible</em></p>
<ol type="1">
<li>Randomization is key</li>
<li>Big, highly variable trees</li>
<li>Average effectively: many trees</li>
</ol>
</div>
<div class="fragment">
<p>Boosting: Adaptively build additive model over trees</p>
<ol type="1">
<li>Trees should not be too big</li>
<li>Learn slowly: Small <span class="math inline">\(\epsilon\)</span>, many trees</li>
</ol>
</div>
<div>
<ul>
<li class="fragment">Both of them take a bunch of bad predictive models (trees) and combine them into a good model!</li>
<li class="fragment">What does this say in terms of implementation and model-size on disk?</li>
</ul>
</div>
<aside class="notes">
<div style="direction:rtl; font-size:16px">
<p>נסכם את מודלי האנסמבל שראינו, רנדום פורסט מול בוסטינג.</p>
<p>רנדום פורסט שואף לבנות בבת אחת הרבה עצים שונים זה מזה ככל שניתן, אנחנו רוצים עצים גדולים, כלומר עמוקים שתהיה להם שונות גבוהה, וככל שנאמן יותר עצים אנחנו יכולים רק להקטין את שגיאת החיזוי על נתוני הטסט.</p>
<p>בבוסטינג העצים נבנים אדפטיבית, הם צריכים להיות לא עמוקים, נעדיף למידה איטית ככל האפשר מה שאומר לשמור את אפסילון נמוך, וגם כאן בפועל, למרות שאין תמיד טיעון תיאורטי טוב כמו ברנדום פורסט, בפועל אנחנו רואים שעוד ועוד עצים משפרים את טעות החיזוי של בוסטינג.</p>
<p>שני המודלים לוקחים מודלים מוגבלים כמו עצים ועושים להם קומבינציה למודל טוב ומורכב. שניהם גם מאוד פופולריים בקרב מדעני נתונים כי לא צריך לכוונן יותר מדי ולהתאים אותם ויש להם ביצועים מעולים.</p>
<p>מבחינת מימוש והאפשרות למקבל את האימון בוסטינג כמובן מאתגר יותר, כי כל עץ צריך להתחשב באלה שקדמו לו. מבחינת הגודל על דיסק דווקא בוסטינג יביא למודלים קטנים יותר שאפשר לשים על כמה שרתים בו זמנית, כי הוא משתמש בעצים שטוחים יותר. זו הרבה פעמים סיבה די טובה להעדיף אותו על רנדום פורסט.</p>
<p>עד כאן על עצים ושילוב שלהם. ביחידה הבאה נדבר על מודל גמיש אחר שאין כמעט איש שלא שמע עליו בשנים האחרונות: רשתות נוירונים.</p>
</div>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>

<img src="../Intro2DS_logo_white.jpg" class="slide-logo r-stretch"><div class="footer footer-default">
<p><a href="https://intro2ds2023.github.io/mooc/" target="_blank">Intro to Data Science</a></p>
</div>
</section>
    </div>
  </div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../libs/revealjs/plugin/reveal-chalkboard/plugin.js"></script>
  <script src="../libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../libs/revealjs/plugin/search/search.js"></script>
  <script src="../libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'smaller': true,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleChalkboard(event)\"><kbd>b</kbd> Toggle Chalkboard</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleNotesCanvas(event)\"><kbd>c</kbd> Toggle Notes Canvas</a></li>\n<li class=\"slide-tool-item\" data-item=\"6\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.downloadDrawings(event)\"><kbd>d</kbd> Download Drawings</a></li>\n<li class=\"slide-tool-item\" data-item=\"7\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":true},
'chalkboard': {"buttons":true},
'smaller': true,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c/t',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, RevealChalkboard, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
    window.document.addEventListener("DOMContentLoaded", function (event) {
      const toggleBodyColorMode = (bsSheetEl) => {
        const mode = bsSheetEl.getAttribute("data-mode");
        const bodyEl = window.document.querySelector("body");
        if (mode === "dark") {
          bodyEl.classList.add("quarto-dark");
          bodyEl.classList.remove("quarto-light");
        } else {
          bodyEl.classList.add("quarto-light");
          bodyEl.classList.remove("quarto-dark");
        }
      }
      const toggleBodyColorPrimary = () => {
        const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
        if (bsSheetEl) {
          toggleBodyColorMode(bsSheetEl);
        }
      }
      toggleBodyColorPrimary();  
      const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
      tabsets.forEach(function(tabset) {
        const tabby = new Tabby('#' + tabset.id);
      });
      const isCodeAnnotation = (el) => {
        for (const clz of el.classList) {
          if (clz.startsWith('code-annotation-')) {                     
            return true;
          }
        }
        return false;
      }
      const clipboard = new window.ClipboardJS('.code-copy-button', {
        text: function(trigger) {
          const codeEl = trigger.previousElementSibling.cloneNode(true);
          for (const childEl of codeEl.children) {
            if (isCodeAnnotation(childEl)) {
              childEl.remove();
            }
          }
          return codeEl.innerText;
        }
      });
      clipboard.on('success', function(e) {
        // button target
        const button = e.trigger;
        // don't keep focus
        button.blur();
        // flash "checked"
        button.classList.add('code-copy-button-checked');
        var currentTitle = button.getAttribute("title");
        button.setAttribute("title", "Copied!");
        let tooltip;
        if (window.bootstrap) {
          button.setAttribute("data-bs-toggle", "tooltip");
          button.setAttribute("data-bs-placement", "left");
          button.setAttribute("data-bs-title", "Copied!");
          tooltip = new bootstrap.Tooltip(button, 
            { trigger: "manual", 
              customClass: "code-copy-button-tooltip",
              offset: [0, -8]});
          tooltip.show();    
        }
        setTimeout(function() {
          if (tooltip) {
            tooltip.hide();
            button.removeAttribute("data-bs-title");
            button.removeAttribute("data-bs-toggle");
            button.removeAttribute("data-bs-placement");
          }
          button.setAttribute("title", currentTitle);
          button.classList.remove('code-copy-button-checked');
        }, 1000);
        // clear code selection
        e.clearSelection();
      });
      function tippyHover(el, contentFn) {
        const config = {
          allowHTML: true,
          content: contentFn,
          maxWidth: 500,
          delay: 100,
          arrow: false,
          appendTo: function(el) {
              return el.closest('section.slide') || el.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'light-border',
          placement: 'bottom-start'
        };
          config['offset'] = [0,0];
          config['maxWidth'] = 700;
        window.tippy(el, config); 
      }
      const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
      for (var i=0; i<noterefs.length; i++) {
        const ref = noterefs[i];
        tippyHover(ref, function() {
          // use id or data attribute instead here
          let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
          try { href = new URL(href).hash; } catch {}
          const id = href.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          return note.innerHTML;
        });
      }
      const findCites = (el) => {
        const parentEl = el.parentElement;
        if (parentEl) {
          const cites = parentEl.dataset.cites;
          if (cites) {
            return {
              el,
              cites: cites.split(' ')
            };
          } else {
            return findCites(el.parentElement)
          }
        } else {
          return undefined;
        }
      };
      var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
      for (var i=0; i<bibliorefs.length; i++) {
        const ref = bibliorefs[i];
        const citeInfo = findCites(ref);
        if (citeInfo) {
          tippyHover(citeInfo.el, function() {
            var popup = window.document.createElement('div');
            citeInfo.cites.forEach(function(cite) {
              var citeDiv = window.document.createElement('div');
              citeDiv.classList.add('hanging-indent');
              citeDiv.classList.add('csl-entry');
              var biblioDiv = window.document.getElementById('ref-' + cite);
              if (biblioDiv) {
                citeDiv.innerHTML = biblioDiv.innerHTML;
              }
              popup.appendChild(citeDiv);
            });
            return popup.innerHTML;
          });
        }
      }
    });
    </script>
    

</body></html>